<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 - Haunted Drive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* ÊÉäÂêìÈó™ÁÉÅÂ±Ç */
        #scare-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red;
            opacity: 0; pointer-events: none; z-index: 50;
            mix-blend-mode: overlay;
            transition: opacity 0.05s;
        }
        .scare-active { opacity: 0.8 !important; }

        /* ÊåâÈîÆÊ†∑Âºè */
        .key-cap {
            display: inline-flex; justify-content: center; align-items: center;
            width: 2rem; height: 2rem; background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 4px;
            color: #fff; margin: 0 2px; font-weight: bold;
        }
        
        /* Âä†ËΩΩ‰∏≠/ÈîôËØØÊèêÁ§∫ */
        #loading { position: fixed; inset:0; background: #000; z-index: 100; display: flex; justify-content: center; align-items: center; color: #059669; }
    </style>
</head>
<body class="antialiased text-white select-none">

    <div id="loading">Ê≠£Âú®Âä†ËΩΩÂºïÊìéËµÑÊ∫ê...</div>
    <div id="scare-overlay"></div>

    <div class="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-8 z-20">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-6xl font-bold text-red-600 drop-shadow-[0_2px_10px_rgba(220,38,38,0.8)]">404</h1>
                <div class="mt-2 flex items-center gap-3">
                    <span id="weather-badge" class="px-2 py-1 rounded text-xs border bg-black/50 backdrop-blur"></span>
                    <span class="text-gray-400 text-sm">‰ø°Âè∑‰∏≠Êñ≠ // ÂØªÊâæË∑ØÊ†á</span>
                </div>
            </div>
            
            <div class="bg-zinc-900/80 border border-zinc-700 p-4 rounded-lg backdrop-blur-sm text-xs text-gray-300">
                <div class="mb-2 text-center text-zinc-500">CONTROL</div>
                <div class="flex justify-center mb-1"><span class="key-cap">W</span></div>
                <div class="flex justify-center">
                    <span class="key-cap">A</span><span class="key-cap">S</span><span class="key-cap">D</span>
                </div>
            </div>
        </div>
        
        <div id="interaction-ui" class="text-center transition-all duration-300 opacity-0 transform translate-y-8">
            <div class="inline-block bg-emerald-950/90 border border-emerald-500/50 rounded-xl px-8 py-5 shadow-[0_0_30px_rgba(16,185,129,0.3)]">
                <div class="text-3xl font-bold text-emerald-400 mb-1 tracking-wider">EXIT FOUND</div>
                <div class="text-emerald-200 text-sm">PRESS <span class="bg-emerald-500 text-black px-2 py-0.5 rounded font-bold mx-1">ENTER</span> TO ESCAPE</div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        const CONFIG = {
            destinations: [
                { text: '‰∏ªÈ°µ', url: 'https://iam.xujingyichang.top/', color: '#10b981' }, // Emerald
                { text: 'ÂçöÂÆ¢', url: 'https://blogs.xujingyichang.top', color: '#3b82f6' }, // Blue
                { text: 'GitHub', url: 'https://github.com/WtecHtec', color: '#8b5cf6' }, // Purple
                { text: 'ËÅîÁ≥ªÊàë', url: 'https://iam.xujingyichang.top/', color: '#f59e0b' } // Amber
            ],
            weather: Math.random() > 0.5 ? 'rain' : 'fog', 
            ghostCount: 12,
            worldSize: 400
        };

        const wBadge = document.getElementById('weather-badge');
        if (CONFIG.weather === 'rain') {
            wBadge.innerText = '‚õàÔ∏è Èò¥Èõ®ÁªµÁªµ';
            wBadge.className += ' border-blue-800 text-blue-300';
        } else {
            wBadge.innerText = 'üå´Ô∏è ÊµìÈõæË≠¶Âëä';
            wBadge.className += ' border-gray-600 text-gray-300';
        }

        let scene, camera, renderer;
        let car, wheels = [], rainSystem;
        let signPost, currentTarget;
        let ghosts = [];
        let isCloseToSign = false;
        let scareCooldown = 0;
        
        const input = { w: false, a: false, s: false, d: false };
        const physics = { speed: 0, acceleration: 0.02, friction: 0.96, maxSpeed: 0.8, turnSpeed: 0.05 };

        window.onload = function() {
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').innerText = "Âä†ËΩΩÂ§±Ë¥•: Unpkg ËøûÊé•Ë∂ÖÊó∂";
                document.getElementById('loading').style.color = "red";
                return;
            }
            try {
                init();
                document.getElementById('loading').style.display = 'none';
                // üü¢ ËøôÈáåË∞ÉÁî® animateÔºåÁé∞Âú®‰∏ãÊñπÂ∑≤ÁªèÊ≠£Á°ÆÂÆö‰πâ‰∫ÜËØ•ÂáΩÊï∞
                animate();
            } catch (e) {
                console.error(e);
                document.getElementById('loading').innerText = "ÈîôËØØ: " + e.message;
            }
        };

        function init() {
            currentTarget = CONFIG.destinations[Math.floor(Math.random() * CONFIG.destinations.length)];

            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            
            const fogColor = 0x020205; 
            scene.background = new THREE.Color(fogColor);
            const fogDensity = CONFIG.weather === 'rain' ? 0.012 : 0.025;
            scene.fog = new THREE.FogExp2(fogColor, fogDensity);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x445566, 0.8); 
            scene.add(ambientLight);

            const moonLight = new THREE.DirectionalLight(0xaaccff, 2); 
            moonLight.position.set(-50, 100, -50);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            moonLight.shadow.camera.left = -100;
            moonLight.shadow.camera.right = 100;
            moonLight.shadow.camera.top = 100;
            moonLight.shadow.camera.bottom = -100;
            scene.add(moonLight);

            createGround();
            createForest();
            createGhosts();
            if (CONFIG.weather === 'rain') createRain();

            const angle = (Math.random() - 0.5) * Math.PI; 
            const dist = 50 + Math.random() * 50; 
            createSignPost(Math.sin(angle) * dist, -Math.cos(angle) * dist);

            car = createCar();
            scene.add(car);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', (e) => handleKey(e, true), false);
            window.addEventListener('keyup', (e) => handleKey(e, false), false);
        }

        // üü¢ Ë°•Âõû animate ÂáΩÊï∞
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            updatePhysics();
            updateGhosts(time);
            updateRain();
            updateCamera();
            checkInteraction();
            
            renderer.render(scene, camera);
        }

        function handleKey(e, isPressed) {
            const key = e.key.toLowerCase();
            if (input.hasOwnProperty(key)) input[key] = isPressed;
            if (e.key === 'Enter' && isPressed && isCloseToSign) {
                document.body.style.transition = 'opacity 1s';
                document.body.style.opacity = '0';
                setTimeout(() => window.location.href = currentTarget.url, 1000);
            }
        }

        function updatePhysics() {
            if (input.w) physics.speed += physics.acceleration;
            if (input.s) physics.speed -= physics.acceleration;
            physics.speed *= physics.friction;
            if (Math.abs(physics.speed) < 0.001) physics.speed = 0;
            
            if (Math.abs(physics.speed) > 0.01) {
                const dir = physics.speed > 0 ? 1 : -1;
                if (input.a) car.rotation.y += physics.turnSpeed * dir;
                if (input.d) car.rotation.y -= physics.turnSpeed * dir;
            }

            car.translateZ(-physics.speed);
            wheels.forEach(w => w.rotation.x += physics.speed * 2);
            car.children[0].position.y = 0.8 + Math.sin(Date.now() * 0.02) * 0.01 * (Math.abs(physics.speed)*10);
        }

        function updateGhosts(time) {
            const carDir = new THREE.Vector3();
            car.getWorldDirection(carDir); 
            carDir.normalize();

            ghosts.forEach(ghost => {
                ghost.position.y = 1.8 + Math.sin(time * 2 + ghost.userData.offset) * 0.3;
                ghost.lookAt(car.position);

                if (scareCooldown > 0) return;

                const dist = ghost.position.distanceTo(car.position);
                if (dist < 3) { triggerScare(); return; }

                if (dist < 35) {
                    const dirToGhost = new THREE.Vector3().subVectors(ghost.position, car.position).normalize();
                    const angle = carDir.dot(dirToGhost);
                    if (angle > 0.9) triggerScare();
                }
            });

            if (scareCooldown > 0) scareCooldown--;
        }

        function triggerScare() {
            const overlay = document.getElementById('scare-overlay');
            overlay.classList.add('scare-active');
            camera.position.x += (Math.random() - 0.5) * 1;
            camera.position.y += (Math.random() - 0.5) * 1;
            setTimeout(() => { overlay.classList.remove('scare-active'); }, 100);
            scareCooldown = 60;
        }

        function updateCamera() {
            const offset = new THREE.Vector3(0, 6, 12);
            offset.applyMatrix4(car.matrixWorld);
            camera.position.lerp(offset, 0.1);
            camera.lookAt(car.position.x, car.position.y + 1, car.position.z);
        }

        function checkInteraction() {
            if (!signPost) return;
            const dist = car.position.distanceTo(signPost.position);
            const ui = document.getElementById('interaction-ui');
            if (dist < 10) {
                if (!isCloseToSign) {
                    isCloseToSign = true;
                    ui.classList.remove('opacity-0', 'translate-y-8');
                }
            } else {
                if (isCloseToSign) {
                    isCloseToSign = false;
                    ui.classList.add('opacity-0', 'translate-y-8');
                }
            }
        }

        function updateRain() {
            if (!rainSystem) return;
            const positions = rainSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.6; // Á®ÄÁñèÂêéÁöÑÊÖ¢ÈÄü‰∏ãËêΩ
                if (positions[i] < 0) positions[i] = 60; 
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;
            rainSystem.position.x = car.position.x;
            rainSystem.position.z = car.position.z;
        }

        function createRain() {
            const geo = new THREE.BufferGeometry();
            const count = 1500; // ÂáèÂ∞ëÈõ®Êª¥Êï∞Èáè
            const positions = [];
            for(let i=0; i<count; i++) {
                positions.push((Math.random()-0.5)*120); 
                positions.push(Math.random()*60);         
                positions.push((Math.random()-0.5)*120); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ 
                color: 0xaaaaaa, 
                size: 0.25, 
                transparent:true, 
                opacity:0.6 
            });
            rainSystem = new THREE.Points(geo, mat);
            scene.add(rainSystem);
        }

        function createCar() {
            const group = new THREE.Group();
            
            const bodyGeo = new THREE.BoxGeometry(2.2, 1, 4.5);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xb91c1c, roughness: 0.2, metalness: 0.5 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            body.castShadow = true;
            group.add(body);

            const glassGeo = new THREE.BoxGeometry(2, 0.8, 2.5);
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0, metalness: 0.8 });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.set(0, 1.6, -0.5);
            glass.castShadow = true;
            group.add(glass);

            const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 24);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            const wheelPos = [[-1.2, 1.5], [1.2, 1.5], [-1.2, -1.5], [1.2, -1.5]];
            wheelPos.forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI / 2;
                w.position.set(p[0], 0.4, p[1]);
                w.castShadow = true;
                wheels.push(w);
                group.add(w);
            });

            // Âº∫ÂäõËΩ¶ÁÅØ
            const leftLight = new THREE.SpotLight(0xfffff0, 5, 60, 0.6, 0.5, 1);
            leftLight.position.set(-0.8, 1, -1.8);
            leftLight.target.position.set(-0.8, 0, -25);
            leftLight.intensity = 3000; 
            leftLight.angle = 0.5;
            leftLight.penumbra = 0.3;
            leftLight.distance = 80;
            leftLight.castShadow = true;
            group.add(leftLight);
            group.add(leftLight.target);

            const rightLight = leftLight.clone();
            rightLight.position.set(0.8, 1, -1.8);
            rightLight.target.position.set(0.8, 0, -25);
            group.add(rightLight);
            group.add(rightLight.target);
            
            const tailLight = new THREE.PointLight(0xff0000, 10, 5);
            tailLight.position.set(0, 1, 2.3);
            group.add(tailLight);

            return group;
        }

        function createGhosts() {
            const geo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, transparent: true, opacity: 0.3,
                emissive: 0x88ccff, emissiveIntensity: 2, roughness: 0.1
            });
            for(let i=0; i<CONFIG.ghostCount; i++) {
                const ghost = new THREE.Mesh(geo, mat);
                let x, z;
                do {
                    x = (Math.random() - 0.5) * CONFIG.worldSize * 0.7;
                    z = (Math.random() - 0.5) * CONFIG.worldSize * 0.7;
                } while(Math.sqrt(x*x + z*z) < 30);
                ghost.position.set(x, 2, z);
                ghost.userData = { offset: Math.random() * 100 };
                const eyeGeo = new THREE.SphereGeometry(0.12);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.2, 0.4, 0.45);
                const rightEye = leftEye.clone();
                rightEye.position.set(0.2, 0.4, 0.45);
                ghost.add(leftEye); ghost.add(rightEye);
                scene.add(ghost);
                ghosts.push(ghost);
            }
        }

        function createSignPost(x, z) {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 7),
                new THREE.MeshStandardMaterial({ color: 0x222 })
            );
            pole.position.y = 3.5; pole.castShadow = true; group.add(pole);
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#047857'; ctx.fillRect(0,0,512,256);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 15; ctx.strokeRect(10,10,492,236);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 70px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(currentTarget.text, 256, 128);
            const texture = new THREE.CanvasTexture(canvas);
            const board = new THREE.Mesh(
                new THREE.BoxGeometry(4, 2, 0.2),
                new THREE.MeshStandardMaterial({ map: texture, emissive: 0x047857, emissiveIntensity: 0.5 })
            );
            board.position.y = 6; group.add(board);
            const beacon = new THREE.PointLight(0x10b981, 100, 50); 
            beacon.position.y = 7.5; group.add(beacon);
            group.position.set(x, 0, z); group.lookAt(0,0,0);
            scene.add(group);
            signPost = group;
        }

        function createGround() {
            const geo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, 64, 64);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a, roughness: CONFIG.weather === 'rain' ? 0.1 : 0.8, metalness: 0.2
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2; mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createForest() {
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 2, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x1a1510 });
            const leafGeo = new THREE.ConeGeometry(2.5, 6, 5);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x0f1f25, roughness: 0.9 });
            for(let i=0; i<150; i++) {
                const group = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1;
                const leaf = new THREE.Mesh(leafGeo, leafMat);
                leaf.position.y = 4;
                trunk.castShadow = true; trunk.receiveShadow = true;
                leaf.castShadow = true; leaf.receiveShadow = true;
                group.add(trunk); group.add(leaf);
                const r = 30 + Math.random() * (CONFIG.worldSize/2 - 30);
                const a = Math.random() * Math.PI * 2;
                group.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
                group.scale.setScalar(0.8 + Math.random()*0.8);
                scene.add(group);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>